console.log('number' + 3 + 3);
/* тут спрацювала конкатенація рядків,'number' це рядок тому 
спочатку відбувається конкатенація між рядком і 3, отримуємо
 number3 і знову конкатенація , тому результат тгьиук33*/
console.log(null + 3);
/* null в цьому випадку - відсутність значення, тому 
відутність значення +3 =3*/
console.log(5 && "qwerty");
/* лівий операнд є істинним і правий також
(будь - який не порожній рядок є істинним), 
якщо обидва операнди істинні то оператор && повертає
 значення правого операнда.*/
console.log(+'40' + +'2' + "hillel");
/* унарний плюс перед рядком приводить його до числа, 
40 і 2 додаються, а потім конкатенація з "hillel"*/
console.log('10' - 5 === 6);
/* спочатку віднімання,а потім порівняння 2-ох чисел, 
10-5=5, а 5 не =6, тому false;*/
console.log(true + false);
// тут все просто - 1+0=1
console.log('4px' - 3);
/*лівий операнд не є чисто цифорвим, тому від нього 
не можна відняти цифру. NAN;*/
console.log('4' - 3);
/* теж просто: рядок 4 перетворюється в число, 
так як містить цифри, а потім віднімання*/
console.log('6' + 3** 0);
/*тут я розумію так: 3 в нульвій степені =1, а потім або 
додавання і вийшло 61, або канкатенація..., конкатенація! 
(спробувала 3 в 3-ій степені, вийшло 627)*/
console.log(12 / '6');
/*Java перетворює рядок на число (коли можливо) і коли бачить 
математичну операцію між числом і рядком, 6 перетворєється на число, тому 2*/
console.log('10' + (5 === 6));
/* перша дія порівняння, результат false, який стає 
рядком - бо це булеве значення, а потім конкатенація з рядком 10*/
console.log(null == '');
// це описували в нашому чаті ))))
console.log(3 ** (9 / 3));
// перша дія в дужках =3 потім зводимо в ступінь
console.log(!!'false' == !!'true');
/* false перетворюється в true, так як будь-який не пустий рядок є true,
 потім ! який змынюэ булеве значення на пртилежне і ще один! 
 який ще раз на пртилежне, в ітозі маємо true, 
 за тією ж схемою ів другій частині, тому true рівне true*/
console.log(0 || '0' && 1);
/* 0 без лапок є це false, з лапками - true, порівнюючи їх, 
буде true (істинний) тобто результат буде '0'&& 1 ,
 обидва операнди є true, результатом має бути останній операнд*/
console.log((+null == false) < 1);
 /* +null перетворюється в число, бо є плюсик спереду, тобто це 0,
порівняти 0 з false ми отримаємо true бо воно не рівне 0,
тобто це правда що вони не дорівнюють ,true перетвороюється в 1
1 не є меншим за 1 тому false . (Боже, який капець, тутвсе залежить від того,
як поставити питання, взагалі я дкмала що має бути true, але консоль показала
по іншому, то прийшлось вигадувати)*/
console.log(false && true || true);
/* язнаю що при операції && (це пріоритетніша операція), якщо 
перший операнд є false, то другий вже не оцінюється і маємо false , 
тобто буде false || true, оператор повертає true, якщо хоч один з 
операндів є true при операції ||*/
console.log(false && (false || true));
/* false || true тут як в попередньому - true,
виходить false && true, так як один з операндів є false,
при операції && завжди повертається false*/
console.log((+null == false) < 1 ** 5);
/* перше робиться в дужках, +null перетворилось на 0, тепер порівнюємо 
з false, який теж прирівняно до о, тобто в дужках маємо true,
true це 1. Потім зводимо 1 в степінь, буде 1, а 1не є менше за 1,
тому false*/


